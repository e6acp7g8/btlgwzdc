# Debugging and profiling

## Building the C-Rust bindings

When required, you can rebuild all of the C-Rust bindings by running:

```bash
cd build && cmake --target bindings .. && make bindings
```

To see the specific options/flags provided to bindgen and cbindgen, you can use
`make VERBOSE=1 bindings`.

Since the C bindings and Rust bindings rely on each other, you may sometimes
need to build the bindings in a specific order. Instead of `make bindings`, you
can be more specific using for example `make bindings_main_rust` to make the
Rust bindings for `src/main`.

You may need to install bindgen, cbindgen, and clang:

```bash
apt install -y clang
cargo install --force --version 0.18.0 cbindgen
cargo install --force --version 0.57.0 bindgen
```

The versions of bindgen and cbindgen you install should match the [versions
installed in the
CI](https://github.com/shadow/shadow/blob/main/.github/workflows/lint.yml).

## Extra tests

Shadow includes tests that require additional dependencies, such as Tor, TGen,
and networkx. These aren't run by default, but are run as part of the CI tests.
To run them locally, first make sure that both tor and tgen are located at
`~/.local/bin/{tor,tgen}`. These can be symlinks to tor and tgen binaries
elsewhere in the filesystem. You should also install all of Shadow's optional
dependencies.

It is recommended to build Shadow in release mode, otherwise the Tor tests may
not complete before the timeout.

```bash
./setup test -- --build-config extra
# To exclude the Tor tests (for example if you built Shadow in debug mode)
./setup test -- --build-config extra --label-exclude tor
```

If you change the version of tor located at `~/.local/bin/tor`, make sure to
re-run `./setup build --test`.

## Debugging

### Debugging Shadow using GDB

Shadow is currently built with debugging symbols in both debug and release
builds, though it may be easier to debug a debug build (generated by passing the
`--debug` flag to `setup build`).

Shadow can be run under `gdb` by prepending `gdb --args` to its command-line.
e.g.:

```
gdb --args shadow shadow.config.xml
```

An alternative is to run shadow with the `-g` flag, which will pause shadow
after startup and print the `PID`. You can then simply attach gdb to shadow in a
new terminal and continue the experiment:

```
shadow -g shadow.config.xml
# new terminal
gdb --pid=PID
> continue
```

Note though, that GDB's `follow-fork-mode` setting should be left in its default
setting of `parent`; see below.

### Debugging virtual processes

As of Shadow 2.0, virtual processes in the simulation are implemented as native
OS processes, with their syscalls interposed by Shadow. Since they are native
processes, many normal tools for inspecting native processes can be used on
those as well. e.g. `top` will show how much CPU and memory they are using.

However, in its default mode of operation, Shadow uses ptrace to control these
processes. Since Linux only allows a process to be ptraced by one other process
at a time, gdb *cannot* attach to those processes.

If a virtual process is crashing (e.g. being killed by a signal within the
simulation), it is still possible to use gdb to help debug it by causing the
native process to generate a core file, and then using gdb to inspect it
afterwards:

```
# Enable core dumps
ulimit -c unlimited

# Run the simulation in which a process is crashing
shadow shadow.config.xml

# Tell gdb to inspect the core file. From within gdb you'll be able to
# inspect the state of the process just before it was killed. 
gdb <path-to-process-executable> <path-to-core-file>

# It's often useful to look at the stack backtrace:
> bt

# Or for a multi-threaded process, to look at all of the threads' backtraces:
> thread apply all bt
```

### Tracing Shadow using Valgrind

If you want to be able to run Shadow through valgrind and the application you
are running in Shadow uses OpenSSL (e.g. `tor`), you should configure OpenSSL
with the additional option: `-DPURIFY`. This fixes OpenSSL so it doesn't break
valgrind. You may also want to ensure that debugging symbols are included in the
GLib that Shadow links to, and any library used by the plug-in. This can be
achieved with the compiler flag `-g` when manually building a local version of
GLib.

### Profiling Shadow

#### Profiling with `gprof`

This method only provides profiling info for the core of Shadow, not for
plug-ins, or other libraries. Also, the profiling info is limited since gprof
only measures active CPU usage and function call counts and misses performance
related to blocking IO and barrier waits.

```bash
./setup build -cgo
./setup install
cd resource/examples
shadow shadow.config.xml > shadow.log
gprof `which shadow` gmon.out > analysis.txt
less analysis.txt
```

#### Profiling with `perf`

Either run perf when starting Shadow:

```bash
perf record shadow shadow.config.yaml > shadow.log
```

Or, connect to a running Shadow process:

```bash
perf record -p <PID>
```

Either of the above two options will write a `perf.data` file when you press
control-c, or Shadow ends. You can then analyze the report:

```bash
perf report
```

Perf is extremely powerful with many options. See `man perf` or [the perf
wiki](https://perf.wiki.kernel.org/index.php/Tutorial) for more info.

Note that any time an example uses the `-g` option in `perf record`, you should
use `--call-graph dwarf` instead. (The `-g` option defaults to stack frames for
traces, which elf-loader and certain optimizations can break. If you see
absurdly tall or small call graphs, this is probably what happened.)

### Testing for Deterministic Behavior

If you run Shadow twice with the same seed (the `-s` or `--seed` command line
options), then it _should_ produce deterministic results (it's a bug if it
doesn't).

A good way to check this is to compare the log output of an application that was
run in Shadow. For example, after running two TGen experiments where the results
are in the `shadow.data.1` and `shadow.data.2` directories, you could run
something like the following bash script:

```bash
#!/bin/bash

found_difference=0

for SUFFIX in \
    hosts/fileserver/stdout-fileserver.tgen.1000.log \
    hosts/client/stdout-client.tgen.1000.log
do
    ## ignore memory addresses in log file with `sed 's/0x[0-9a-f]*/HEX/g' FILENAME`
    sed -i 's/0x[0-9a-f]*/HEX/g' shadow.data.1/${SUFFIX}
    sed -i 's/0x[0-9a-f]*/HEX/g' shadow.data.2/${SUFFIX}

    diff --brief shadow.data.1/${SUFFIX} shadow.data.2/${SUFFIX}
    exit_code=$?

    if (($exit_code != 0)); then
      found_difference=1
    fi
done

if (($found_difference == 1)); then
  echo -e "\033[0;31mDetected difference in output (Shadow may be non-deterministic).\033[0m"
else
  echo -e "\033[0;32mDid not detect difference in Shadow output (Shadow may be deterministic).\033[0m"
fi
```

If you find non-deterministic behavior in your Shadow experiment, please
consider helping to diagnose the problem by opening a [new
issue](https://github.com/shadow/shadow/issues/new).

### Building the Guide

```bash
cargo install mdbook
(cd mdbook && mdbook build)
firefox build/guide/index.html
```
